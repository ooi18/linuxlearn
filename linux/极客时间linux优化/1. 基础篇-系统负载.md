#### 基础篇-平均负载

平均负载指的是在单位时间内,系统处于可运行状态和不可终端状态的平均进城数量也就是平均活跃进程数量, 它和 cpu 使用率并没有直接关系.

* 运行状态进程: 指的是正在使用cpu 或者正在等待 cpu 的进程,也就是我们看到处于 R状态(Running 或 Runnable)的进程
* 不可终端状态的进程: 处于内核态关键流程中的进程,并且这些流程不可以被终端.比如等待硬件设备的I/O响应,也就是我们在ps命令中看到的 D (Uninterruptible Sleep ,也称为 Disk Sleep)状态

不可中断状态实际是系统对进程和设备的一种保护机制


平均负载为2 以为这什么?

* 在只有2和cpu 的系统上,意味着所有系统的cpu 凑刚好完全占用
* 在4个 cpu 的系统上,意味着cpu有 50%的空闲
* 而在只有1个cpu的系统中,则意味着有一个半的进程竞争不到CPU
* 如果CPU支持超线程:则负载应该小于等于 cpu数量*核心数*2(也就是逻辑cpu 数量)

查看 CPU数量

    grep 'model name' /proc/cpuinfo | wc -l
    2

CPU 使用率,是单位时间内 CPU 繁忙情况的统计,和平均负载不一定完全对应比如:
* CPU 密集型进程,使用大量CPU会导致平均负载升高,此时这两者一致
* I/O密集型进程,等待I/O也会导致平均负载升高,但是CPU使用率不一定很高
* 大量等待CPU的进程调度也会导致CPU负载升高,此时的CPU使用率也会比较高


平均负载案例分析:

场景一:CPU 密集型进程

    $ stress --cpu 1 --timeout 600

    # -d 参数表示高亮显示变化的区域
    $ watch -d uptime
    ...,  load average: 1.00, 0.75, 0.39


    # -P ALL 表示监控所有 CPU，后面数字 5 表示间隔 5 秒后输出一组数据
    $ mpstat -P ALL 5
    Linux 4.15.0 (ubuntu) 09/22/18 _x86_64_ (2 CPU)
    13:30:06     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
    13:30:11     all   50.05    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00   49.95
    13:30:11       0    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
    13:30:11       1  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00


从终端二种可以看到,1分钟的平均负载会慢慢增加到1.00,而从终端三种看到 CPU 100%,但是 iowait 只有0,说明平均负载高是因为 cpu 引起的.

那么,到底是哪个进程导致了 CPU 使用率为100哪?你可以使用 pidstat 来查询

    # 间隔 5 秒后输出一组数据
    $ pidstat -u 5 1
    13:37:07      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
    13:37:12        0      2962  100.00    0.00    0.00    0.00  100.00     1  stress


场景二：I/O 密集型进程

首先还是运行 stress 命令，但这次模拟 I/O 压力，即不停地执行 sync：

    $ stress -i 1 --timeout 600

还是在第二个终端运行 uptime 查看平均负载的变化情况：

    $ watch -d uptime
    ...,  load average: 1.06, 0.58, 0.37

然后，第三个终端运行 mpstat 查看 CPU 使用率的变化情况：

    # 显示所有 CPU 的指标，并在间隔 5 秒输出一组数据
    $ mpstat -P ALL 5 1
    Linux 4.15.0 (ubuntu)     09/22/18     _x86_64_    (2 CPU)
    13:41:28     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
    13:41:33     all    0.21    0.00   12.07   32.67    0.00    0.21    0.00    0.00    0.00   54.84
    13:41:33       0    0.43    0.00   23.87   67.53    0.00    0.43    0.00    0.00    0.00    7.74
    13:41:33       1    0.00    0.00    0.81    0.20    0.00    0.00    0.00    0.00    0.00   98.99

从这里可以看到，1 分钟的平均负载会慢慢增加到 1.06，其中一个 CPU 的系统 CPU 使用率升高到了 23.87，而 iowait 高达 67.53%。这说明，平均负载的升高是由于 iowait 的升高。

那么到底是哪个进程，导致 iowait 这么高呢？我们还是用 pidstat 来查询：

    # 间隔 5 秒后输出一组数据，-u 表示 CPU 指标
    $ pidstat -u 5 1
    Linux 4.15.0 (ubuntu)     09/22/18     _x86_64_    (2 CPU)
    13:42:08      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
    13:42:13        0       104    0.00    3.39    0.00    0.00    3.39     1  kworker/1:1H
    13:42:13        0       109    0.00    0.40    0.00    0.00    0.40     0  kworker/0:1H
    13:42:13        0      2997    2.00   35.53    0.00    3.99   37.52     1  stress
    13:42:13        0      3057    0.00    0.40    0.00    0.00    0.40     0  pidstat

可以发现，还是 stress 进程导致的。

场景三：大量进程的场景

当系统中运行进程超出 CPU 运行能力时，就会出现等待 CPU 的进程。

比如，我们还是使用 stress，但这次模拟的是 8 个进程：

    $ stress -c 8 --timeout 600

由于系统只有 2 个 CPU，明显比 8 个进程要少得多，因而，系统的 CPU 处于严重过载状态，平均负载高达 7.97：

    $ uptime
    ...,  load average: 7.97, 5.93, 3.02

接着再运行 pidstat 来看一下进程的情况：

    # 间隔 5 秒后输出一组数据
    $ pidstat -u 5 1
    14:23:25      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
    14:23:30        0      3190   25.00    0.00    0.00   74.80   25.00     0  stress
    14:23:30        0      3191   25.00    0.00    0.00   75.20   25.00     0  stress
    14:23:30        0      3192   25.00    0.00    0.00   74.80   25.00     1  stress
    14:23:30        0      3193   25.00    0.00    0.00   75.00   25.00     1  stress
    14:23:30        0      3194   24.80    0.00    0.00   74.60   24.80     0  stress
    14:23:30        0      3195   24.80    0.00    0.00   75.00   24.80     0  stress
    14:23:30        0      3196   24.80    0.00    0.00   74.60   24.80     1  stress
    14:23:30        0      3197   24.80    0.00    0.00   74.80   24.80     1  stress
    14:23:30        0      3200    0.00    0.20    0.00    0.20    0.20     0  pidstat


可以看出，8 个进程在争抢 2 个 CPU，每个进程等待 CPU 的时间（也就是代码块中的 %wait 列）高达 75%。这些超出 CPU 计算能力的进程，最终导致 CPU 过载。



#### # 小结

在理解平均负载时，也要注意：

* 平均负载高有可能是 CPU 密集型进程导致的；

* 平均负载高并不一定代表 CPU 使用率高，还有可能是 I/O 更繁忙了；

* 当发现负载高的时候，你可以使用 mpstat、pidstat 等工具，辅助分析负载的来源。