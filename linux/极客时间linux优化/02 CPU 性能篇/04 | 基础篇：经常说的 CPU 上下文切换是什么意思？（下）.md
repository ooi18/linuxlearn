04 | 基础篇：经常说的 CPU 上下文切换是什么意思？（下）
----

#### # 怎么查看系统的上下文切换情况

    # 每隔 5 秒输出 1 组数据
    $ vmstat 5
    procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
    r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
    0  0      0 7005360  91564 818900    0    0     0     0   25   33  0  0 100  0  0

- cs (context switch ) 每秒上下文切换次数
- in (interrupt ) 每秒终端次数
- r (Running or Runnable ) 就绪队列长度,也就是正在运行和等待 CPU 的进程数
- b (Blocked) 则是出于不可中断睡眠状态的进程数

> vmstat 只能看到系统总体上下文切换,如果需要查看具体进程的,需要使用 `pidstat -w` 命令

    # 每隔 5 秒输出 1 组数据
    $ pidstat -w 5
    Linux 4.15.0 (ubuntu)  09/23/18  _x86_64_  (2 CPU)

    08:18:26      UID       PID   cswch/s nvcswch/s  Command
    08:18:31        0         1      0.20      0.00  systemd
    08:18:31        0         8      5.40      0.00  rcu_sched
    ...

- cswch 表示每秒资源上下文切换次数
- nvcswch 每秒非自愿上下文切换次数

他们意味着不同的性能问题:
- 所谓**资源资源上下文切换,是指进程无法获取所需资源,导致上下文切换**,比如说,I/O,内存等资源不足时,就会发生资源上下文切换
- 而**非自愿上下文切换,则是指进程由于时间片已到等原因,被系统强制调度,进而发生上下文切换**,比如说,大量进程都在争抢CPu时,就容易发生资源上下文切换.

案例分析
----

sysbench 是一个多线程基准测试工具,一般用来评估不同系统参数下的数据库负载情况,当然,在这次案例中,我们只把他当做一个异常的进程来看,作用是模拟上下文切换过多的问题.

    sysbench --num-threads=10 --max-time=300 --test=threads run
    $ vmstat 1 10
    procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
    r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
    0  0      0 462788 525788 1279912    0    0     2    13    1    2  1  1 98  0  0
    0  0      0 461784 525788 1279912    0    0     0     4  757 1270  1  5 94  0  0
    9  0      0 461708 525788 1279916    0    0     0     4 22072 1592310  9 84  7  0  0
    7  0      0 461128 525788 1279916    0    0     0   264 21866 1774944  9 85  5  0  0

可以看到 r 飙升到了9,中断次数高达2w,上下文切换高达 159w, sy + us 几乎 100%

- -r 列: 就绪队列长度已经到了8,远远超过系统cpu的个数2,所以肯定存在大量的cpu竞争
- us,sy 列:加起来几乎100%,其中系统cpu使用率高达84%,说明cpu 被内核占用了
- in 列: 中断次数上升到2w左右,说明中断处理也存在潜在问题.




    # 每隔 1 秒输出 1 组数据（需要 Ctrl+C 才结束）
    # -w 参数表示输出进程切换指标，而 -u 参数则表示输出 CPU 使用指标
    $ pidstat -w -u 1
    08:06:33      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
    08:06:34        0     10488   30.00  100.00    0.00    0.00  100.00     0  sysbench
    08:06:34        0     26326    0.00    1.00    0.00    0.00    1.00     0  kworker/u4:2

    08:06:33      UID       PID   cswch/s nvcswch/s  Command
    08:06:34        0         8     11.00      0.00  rcu_sched
    08:06:34        0        16      1.00      0.00  ksoftirqd/1
    08:06:34        0       471      1.00      0.00  hv_balloon
    08:06:34        0      1230      1.00      0.00  iscsid
    08:06:34        0      4089      1.00      0.00  kworker/1:5
    08:06:34        0      4333      1.00      0.00  kworker/0:3
    08:06:34        0     10499      1.00    224.00  pidstat
    08:06:34        0     26326    236.00      0.00  kworker/u4:2
    08:06:34     1000     26784    223.00      0.00  sshd


pidstat 输出的上下文切换次数,加起来也就几百,比 vmstat 的百万级别显然小太多了,这是为啥?

我们加上 `-t` 看一下

    # 每隔 1 秒输出一组数据（需要 Ctrl+C 才结束）
    # -wt 参数表示输出线程的上下文切换指标
    $ pidstat -wt 1
    08:14:05      UID      TGID       TID   cswch/s nvcswch/s  Command
    ...
    08:14:05        0     10551         -      6.00      0.00  sysbench
    08:14:05        0         -     10551      6.00      0.00  |__sysbench
    08:14:05        0         -     10552  18911.00 103740.00  |__sysbench
    08:14:05        0         -     10553  18915.00 100955.00  |__sysbench
    08:14:05        0         -     10554  18827.00 103954.00  |__sysbench
    ...

虽然 sysbench 进程(也就是主进程)的上下文切换次数不多,但是他的子线程上下文切换次数却很多.看来,上下文切换罪魁祸首,还是过多的 sysbench 线程.

观察 `/proc/interrupts` 系统中断情况

    watch -d cat /proc/interrupts

发现 RES (**重调度中断**)变化比较大,这个中断表示,唤醒空闲状态的CPU 来调度新的任务运行.这是多处理系统(SMP)中,调度器用来分散任务到不同 CPU 的机制,通常也称为**处理器间中断**

根据上下文切换的类型分析性能:

- 资源剩下文切换多了,说明进程都在等待资源,可能发生了I/O等其他问题.
- 非自愿上下文切换多了,说明进程都在被强制调用,也就是都在争夺 CPU ,说明 CPU 的确成了瓶颈
- 中断次数多了,说明CPU 被中断处理程序占用,还需要通过查看 /proc/interrupts 文件来分析具体的中断类型
